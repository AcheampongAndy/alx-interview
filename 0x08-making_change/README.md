# 0x08. Making Change

## Description
This project focuses on solving the classic **coin change problem** using algorithms. The objective is to determine the minimum number of coins needed to make up a given amount using a list of available coin denominations. You will explore and implement solutions using **greedy algorithms** and **dynamic programming** while analyzing their efficiency and limitations.

By completing this project, you will strengthen your understanding of algorithm design and optimization techniques.

---

## Learning Objectives
By the end of this project, you will:

- Understand the principles of **greedy algorithms** and their suitability for certain scenarios.
- Learn about the **limitations of greedy algorithms** and cases where they might fail to find the optimal solution.
- Gain proficiency in **dynamic programming** as a method to solve optimization problems with overlapping subproblems and optimal substructure.
- Analyze the **time and space complexity** of algorithms and work towards efficient implementations.
- Apply **Python programming skills** to manipulate data structures, use list comprehensions, and write clean, efficient functions.

---

## Requirements
- **Environment**:
  - All files will be executed on **Ubuntu 20.04 LTS** using Python **3.4.3**.
- **Style**:
  - All Python code must follow the **PEP 8** style guide (version 1.7.x).
  - Files should end with a new line.
  - The first line of all files must be:
    ```python
    #!/usr/bin/python3
    ```
- **Project Files**:
  - A `README.md` file is mandatory at the root of the project folder.
  - All files must be executable.

---

## Concepts Covered
### 1. **Greedy Algorithms**
- Solve the problem by making the locally optimal choice at each step.
- Suitable for certain coin denominations but may fail in others due to lack of global optimization.

### 2. **Dynamic Programming**
- Divide the problem into smaller subproblems and solve them iteratively or recursively.
- Use a table to store results of subproblems (memoization) to avoid redundant computations.
- Guarantees the correct solution when a **greedy approach** fails.

### 3. **Algorithmic Complexity**
- Analyze the **time complexity** (number of operations) and **space complexity** (memory usage) of your solutions.
- Aim for solutions with lower complexity to handle larger inputs efficiently.

### 4. **Python Programming**
- Efficiently manipulate lists and use list comprehensions.
- Write functions with robust looping and conditional statements to handle edge cases.

---
